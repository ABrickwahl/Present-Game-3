<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Xmas Bitches</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Indie+Flower&family=Caveat&family=Lobster&family=Roboto&display=swap" rel="stylesheet">
<style>
/* --- Dark Cards on Mostly-White Xmas Background --- */
body { 
  font-family: Roboto, sans-serif; 
  background-color: #f5f5f5;  /* fallback if image fails */
  background-repeat: no-repeat;
  background-position: center center;
  background-attachment: fixed;
  background-size: cover;
  color: #fff; 
  padding:20px; 
  margin:0;
}
h1 { 
  margin-bottom:10px; 
  color:#000; 
  text-shadow: 1px 1px 2px #fff; 
  text-align:center; 
}
.card { 
  background: rgba(20,20,20,0.88); 
  padding:15px; 
  border-radius:10px; 
  box-shadow:0 4px 10px rgba(0,0,0,0.5); 
  margin-bottom:15px; 
  color:#fff;
}
input, select, button { padding:8px; margin:5px 0; border-radius:5px; border:none; font-size:16px; }
input, select { background:#444; color:#fff; width:100%; box-sizing:border-box; }
button { cursor:pointer; background:#d9534f; color:#fff; border:none; width:100%; }
button:hover { background:#c9302c; }
button:disabled { opacity:0.55; cursor:not-allowed; }

canvas { border:1px solid #ccc; border-radius:6px; background:#fff; touch-action:none; width:100%; height:auto; }
.entry-card { font-size:26px; text-align:center; margin:15px 0; color:#ffd700; }
.done { color: #28a745; font-weight: bold; }
#winnerCard { display:none; background: rgba(255,215,0,0.9); color:#000; font-size:24px; font-weight:bold; text-align:center; padding:20px; border-radius:10px; box-shadow:0 4px 10px rgba(0,0,0,0.7); }

/* Feedback box */
#feedbackBox {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(-20px);
  z-index: 9999;
  display: none;
  text-align: center;
  font-size: 20px;
  font-weight: bold;
  padding: 10px 20px;
  border-radius: 8px;
  background-color: #28a745;
  color: #fff;
  opacity: 0;
  transition: all 0.4s ease;
}
#feedbackBox.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* Turn banner */
#turnBanner{
  text-align:center;
  font-weight:bold;
  font-size:18px;
}
</style>
</head>
<body>

<h1>ðŸŽ„ 2025 Presents to Present ðŸŽ„</h1>

<div id="feedbackBox"></div>

<!-- Room Join -->
<div class="card" id="roomCard">
  <h3>Create or Join Room</h3>
  <input id="playerName" placeholder="Your name" />
  <input id="roomId" placeholder="Room code" />
  <button onclick="joinRoom()">Join Room</button>
</div>

<!-- Room Info -->
<div class="card" id="roomInfoCard" style="display:none;">
  <h3>Room Code: <span id="displayRoomCode"></span></h3>
  <button onclick="copyRoomCode()">Copy Room Code</button>
</div>

<!-- Players List -->
<div class="card" id="gameCard" style="display:none;">
  <h3>Players</h3>
  <ul id="players"></ul>
</div>

<!-- Add Entry -->
<div class="card" id="entryCard" style="display:none;">
  <h3>Add Entry</h3>
  <select id="entryAuthor"></select><br />
  <input id="entryText" placeholder="Enter text" />
  <select id="style" onchange="toggleTextInput()">
    <option value="font">Random Font</option>
    <option value="handwriting">Handwriting</option>
  </select><br />
  <canvas id="canvas" width="300" height="150"></canvas><br />
  <button onclick="clearCanvas()">Clear Drawing</button>
  <button id="addEntryBtn" onclick="addEntry()">Add Entry</button>
</div>

<!-- Turn Info -->
<div class="card" id="turnCard" style="display:none;">
  <div id="turnBanner">Turn: <span id="turnPlayer">â€”</span></div>
  <div style="text-align:center; font-size:14px; opacity:0.9; margin-top:6px;">
    Each player gets <b>one guess</b> per turn.
  </div>
</div>

<!-- Game Play -->
<div class="card" id="playCard" style="display:none;">
  <h3>Game</h3>
  <button id="drawBtn" onclick="drawEntry()">Draw Random Entry</button>
  <div id="entry"></div>
  <select id="guess"></select>
  <button id="guessBtn" onclick="submitGuess()">Guess</button>
</div>

<!-- Remaining Entries -->
<div class="card" id="remainingCard" style="display:none;">
  Remaining entries: <span id="remaining">0</span>
</div>

<!-- Winner Display -->
<div id="winnerCard"></div>

<script>
// --- Random mostly-white Xmas background (runs immediately) ---
const xmasBackgrounds = [
  // NOTE: Unsplash images should include parameters for reliable sizing/caching.
  "https://images.unsplash.com/photo-1608889175250-c3b0c166c4f3?auto=format&fit=crop&w=1920&q=80",
  "https://images.unsplash.com/photo-1543589077-47d81606c1bf?auto=format&fit=crop&w=1920&q=80",
  "https://images.unsplash.com/photo-1512389098783-66b81f86e199?auto=format&fit=crop&w=1920&q=80",
  "https://images.unsplash.com/photo-1545608444-f045a6db6133?auto=format&fit=crop&w=1920&q=80",
  "https://images.unsplash.com/photo-1608231387042-66d1773070a5?auto=format&fit=crop&w=1920&q=80"
];
document.body.style.backgroundImage =
  `url('${xmasBackgrounds[Math.floor(Math.random()*xmasBackgrounds.length)]}')`;

// --- Firebase config ---
const firebaseConfig = {
  apiKey: "AIzaSyBcfYtibV2vzCG_rchAX8KqUnfJNbnpyQM",
  authDomain: "xmas-guessing-game-e744e.firebaseapp.com",
  projectId: "xmas-guessing-game-e744e",
  storageBucket: "xmas-guessing-game-e744e.firebasestorage.app",
  messagingSenderId: "324648115760",
  appId: "1:324648115760:web:c51e7284128906138ad7f5",
  measurementId: "G-XL91BHP4P4"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

let roomRef;
let playerName = '';
let roomId = '';
const fonts = ['Pacifico','Indie Flower','Caveat','Lobster','Roboto'];
let currentEntry = null;

// --- Canvas setup ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.fillStyle = "white";
ctx.fillRect(0, 0, canvas.width, canvas.height);
let drawing = false;

// --- Desktop drawing ---
canvas.addEventListener('mousedown', () => drawing = true);
canvas.addEventListener('mouseup', () => { drawing = false; ctx.beginPath(); });
canvas.addEventListener('mousemove', draw);

// --- Mobile drawing ---
canvas.addEventListener('touchstart', e => { e.preventDefault(); drawing = true; drawTouch(e); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); drawTouch(e); });
canvas.addEventListener('touchend', e => { e.preventDefault(); drawing = false; ctx.beginPath(); });

function draw(e) {
  if(!drawing) return;
  const rect = canvas.getBoundingClientRect();
  ctx.lineWidth = 2; ctx.lineCap = 'round';
  ctx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
}
function drawTouch(e) {
  if(!drawing) return;
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  ctx.lineWidth = 2; ctx.lineCap = 'round';
  ctx.lineTo(touch.clientX - rect.left, touch.clientY - rect.top);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(touch.clientX - rect.left, touch.clientY - rect.top);
}
function clearCanvas() { 
  ctx.clearRect(0,0,canvas.width,canvas.height); 
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

// Disable text input if handwriting selected
function toggleTextInput(){
  const style = document.getElementById('style').value;
  document.getElementById('entryText').disabled = (style==='handwriting');
}

// --- Feedback Box Function ---
function showFeedback(message,color){
  const fb = document.getElementById('feedbackBox');
  fb.textContent = message;
  fb.style.backgroundColor = color;
  fb.style.color = '#fff';
  fb.classList.add('show');
  fb.style.display='block';
  setTimeout(()=>{ fb.classList.remove('show'); },2000);
}

// --- Helpers for Turn System ---
function sortedPlayerNames(playersObj){
  return Object.keys(playersObj || {}).sort((a,b)=>a.localeCompare(b));
}

async function ensureTurnStateExists(){
  await db.runTransaction(async (tx) => {
    const snap = await tx.get(roomRef);
    const data = snap.data() || {};
    const players = data.players || {};
    const order = sortedPlayerNames(players);

    if(!data.turnOrder || typeof data.turnIndex !== 'number'){
      tx.set(roomRef, {
        turnOrder: order,
        turnIndex: 0,
        currentEntryId: null
      }, { merge:true });
      return;
    }

    const existing = Array.isArray(data.turnOrder) ? data.turnOrder : [];
    const same = existing.length === order.length && existing.every((v,i)=>v===order[i]);
    if(!same){
      const currentName = existing[data.turnIndex] ?? existing[0] ?? null;
      let newIndex = 0;
      if(currentName){
        const idx = order.indexOf(currentName);
        newIndex = (idx >= 0) ? idx : 0;
      }
      tx.set(roomRef, { turnOrder: order, turnIndex: newIndex }, { merge:true });
    }
  });
}

// --- Join Room ---
async function joinRoom() {
  playerName = document.getElementById('playerName').value.trim();
  roomId = document.getElementById('roomId').value.trim();
  if(!playerName || !roomId) return alert('Enter name and room code');

  roomRef = db.collection('games').doc(roomId);

  await roomRef.set({ players: {[playerName]: {count:0, score:0}} }, { merge:true });

  document.getElementById('roomCard').style.display='none';
  document.getElementById('roomInfoCard').style.display='block';
  document.getElementById('displayRoomCode').textContent = roomId;

  document.getElementById('gameCard').style.display='block';
  document.getElementById('entryCard').style.display='block';
  document.getElementById('turnCard').style.display='block';
  document.getElementById('remainingCard').style.display='block';

  await ensureTurnStateExists();
  listenUpdates();
}

// Copy room code
function copyRoomCode() {
  navigator.clipboard.writeText(roomId)
    .then(() => alert('Room code copied!'))
    .catch(()=>alert('Failed to copy.'));
}

// --- Firebase Listeners ---
function listenUpdates() {
  roomRef.onSnapshot(async (snapshot) => {
    const data = snapshot.data() || {};
    updatePlayersList(data.players || {});
    await updateRemaining();

    const order = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(data.players);
    const turnIndex = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
    const currentTurnPlayer = order[turnIndex] || 'â€”';

    document.getElementById('turnPlayer').textContent = currentTurnPlayer;

    const isMyTurn = (currentTurnPlayer === playerName);

    document.getElementById('drawBtn').disabled = !isMyTurn;
    document.getElementById('guessBtn').disabled = !isMyTurn;

    if(!isMyTurn){
      currentEntry = null;
      document.getElementById('entry').innerHTML = '';
    }

    if(data.currentEntryId){
      const entryDoc = await roomRef.collection('entries').doc(data.currentEntryId).get();
      if(entryDoc.exists){
        currentEntry = { id: entryDoc.id, ...entryDoc.data() };
        renderCurrentEntry(currentEntry);
      }
    } else {
      // If no shared entry, clear the display for everyone
      document.getElementById('entry').innerHTML = '';
      currentEntry = null;
    }
  });
}

// --- Render entry (shared) ---
function renderCurrentEntry(entry){
  const div = document.getElementById('entry');
  div.innerHTML = '';
  if(!entry) return;

  if(entry.style==='handwriting'){
    const img = document.createElement('img');
    img.src = entry.image;
    img.width = 300;
    div.appendChild(img);
  } else {
    const p = document.createElement('div');
    p.className='entry-card';
    p.style.fontFamily = entry.font;
    p.textContent = entry.text;
    div.appendChild(p);
  }
}

// --- Update Players ---
function updatePlayersList(players){
  const list = document.getElementById('players');
  list.innerHTML='';
  const authorSelect = document.getElementById('entryAuthor');
  const guessSelect = document.getElementById('guess');
  authorSelect.innerHTML=''; guessSelect.innerHTML='';

  for(const p in players){
    const li = document.createElement('li');
    li.textContent = `${p} (${players[p].count || 0}/3, score: ${players[p].score || 0})`;
    if((players[p].count||0) >= 3) li.className='done';
    list.appendChild(li);

    const o1 = document.createElement('option'); o1.value=p; o1.textContent=p; authorSelect.appendChild(o1);
    const o2 = document.createElement('option'); o2.value=p; o2.textContent=p; guessSelect.appendChild(o2);
  }
}

// --- Add Entry ---
async function addEntry() {
  const text = document.getElementById('entryText').value.trim();
  const author = document.getElementById('entryAuthor').value;
  const style = document.getElementById('style').value;

  if(!author) return showFeedback('Select an author','red');
  if(style === 'font' && !text) return showFeedback('Enter text for font style','red');

  const playerDoc = await roomRef.get();
  const players = (playerDoc.data() || {}).players || {};
  if((players[author]?.count || 0) >= 3) return showFeedback(`${author} already entered 3 items`,'red');

  const entry = { author, style, in_play:true, guessed_correctly:false };

  if(style==='handwriting') entry.image = canvas.toDataURL();
  else {
    entry.text = text;
    entry.font = fonts[Math.floor(Math.random()*fonts.length)];
  }

  await roomRef.collection('entries').doc().set(entry);
  await roomRef.update({ [`players.${author}.count`]: (players[author]?.count||0)+1 });

  clearCanvas();
  document.getElementById('entryText').value='';
  await updateRemaining();
}

// --- Draw Entry (ONLY current turn player can press) ---
// --- Draw Entry (turn player can redraw ONLY if the current drawn entry is theirs) ---
async function drawEntry() {
  // 1) Verify it's your turn, and if an entry is already drawn, only allow redraw if it's YOUR entry
  try {
    await db.runTransaction(async (tx) => {
      const roomSnap = await tx.get(roomRef);
      const data = roomSnap.data() || {};
      const players = data.players || {};
      const order = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(players);
      const idx = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
      const turnPlayer = order[idx];

      if (turnPlayer !== playerName) throw new Error("Not your turn");

      // If there's already a current entry, only allow redraw if it is yours
      if (data.currentEntryId) {
        const entryRef = roomRef.collection('entries').doc(data.currentEntryId);
        const entrySnap = await tx.get(entryRef);
        if (!entrySnap.exists) throw new Error("Current entry missing");

        const entryData = entrySnap.data() || {};
        if (entryData.author !== playerName) {
          throw new Error("You can only redraw if you drew your own entry");
        }
      }
    });
  } catch (err) {
    return showFeedback(err.message || "Cannot draw now", "#d9534f");
  }

  // 2) Get all in-play entries
  const snapshot = await roomRef.collection('entries').where('in_play', '==', true).get();
  const entries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

  if (entries.length === 0) return showFeedback("No entries left", "red");

  // 3) Prefer NOT drawing your own entry (so redraw usually gives a different person)
  const nonSelf = entries.filter(e => e.author !== playerName);
  const pool = (nonSelf.length > 0) ? nonSelf : entries; // fallback if only your entries remain

  const picked = pool[Math.floor(Math.random() * pool.length)];

  // 4) Commit chosen entry as shared currentEntryId (overwriting allowed only if previous was yours)
  try {
    await db.runTransaction(async (tx) => {
      const roomSnap = await tx.get(roomRef);
      const data = roomSnap.data() || {};
      const players = data.players || {};
      const order = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(players);
      const idx = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
      const turnPlayer = order[idx];

      if (turnPlayer !== playerName) throw new Error("Not your turn");

      // If an entry is already drawn, only overwrite if it's your entry
      if (data.currentEntryId) {
        const entryRef = roomRef.collection('entries').doc(data.currentEntryId);
        const entrySnap = await tx.get(entryRef);
        if (!entrySnap.exists) throw new Error("Current entry missing");

        const entryData = entrySnap.data() || {};
        if (entryData.author !== playerName) {
          throw new Error("You can only redraw if you drew your own entry");
        }
      }

      tx.set(roomRef, { currentEntryId: picked.id }, { merge: true });
    });

    if (picked.author === playerName) {
      showFeedback("You drew your own â€” tap Draw again to redraw âœ…", "#f0ad4e");
    }
  } catch (err) {
    return showFeedback(err.message || "Draw failed", "#d9534f");
  }
}


// --- Submit Guess (ONE guess then auto-advance turn) ---
async function submitGuess() {
  const guess = document.getElementById('guess').value;
  if(!guess) return;

  const roomSnap = await roomRef.get();
  const roomData = roomSnap.data() || {};
  if(!roomData.currentEntryId) return showFeedback('Draw an entry first','#d9534f');

  const order = Array.isArray(roomData.turnOrder) ? roomData.turnOrder : sortedPlayerNames(roomData.players || {});
  const idx = (typeof roomData.turnIndex === 'number') ? roomData.turnIndex : 0;
  const turnPlayer = order[idx];

  if(turnPlayer !== playerName) return showFeedback("Not your turn",'#d9534f');

  const entryDoc = await roomRef.collection('entries').doc(roomData.currentEntryId).get();
  if(!entryDoc.exists) return showFeedback('Entry missing','#d9534f');

  currentEntry = { id: entryDoc.id, ...entryDoc.data() };
  const wasCorrect = (guess === currentEntry.author);

  try{
    await db.runTransaction(async (tx) => {
      const snap = await tx.get(roomRef);
      const data = snap.data() || {};
      const players = data.players || {};
      const order2 = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(players);
      const idx2 = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
      const turnPlayer2 = order2[idx2];

      if(turnPlayer2 !== playerName) throw new Error("Not your turn");
      if(!data.currentEntryId) throw new Error("No entry drawn");

      const myScore = players[playerName]?.score || 0;

      if(wasCorrect){
        tx.update(roomRef, { [`players.${playerName}.score`]: myScore + 1 });
        tx.update(roomRef.collection('entries').doc(data.currentEntryId), { guessed_correctly:true, in_play:false });
      }

      const next = (idx2 + 1) % (order2.length || 1);
      tx.set(roomRef, { turnIndex: next, currentEntryId: null }, { merge:true });
    });
  } catch(err){
    return showFeedback(err.message || 'Guess failed','#d9534f');
  }

  if(wasCorrect) showFeedback('âœ… Correct!','#28a745');
  else showFeedback('âŒ Wrong!','#d9534f');

  // Winner check
  const allEntries = await roomRef.collection('entries').get();
  const remaining = allEntries.docs.filter(doc=>!doc.data().guessed_correctly);
  if(remaining.length===0){
    const finalPlayers = (await roomRef.get()).data().players || {};
    let maxScore=-1, winners=[];
    for(const p in finalPlayers){
      const s = finalPlayers[p].score || 0;
      if(s>maxScore){ maxScore=s; winners=[p]; }
      else if(s===maxScore) winners.push(p);
    }
    document.getElementById('winnerCard').style.display='block';
    document.getElementById('winnerCard').textContent = `ðŸŽ‰ Winner: ${winners.join(', ')} with ${maxScore} points! ðŸŽ‰`;
    document.getElementById('playCard').style.display='none';
  }

  currentEntry = null;
  document.getElementById('entry').innerHTML='';
  await updateRemaining();
}

// --- Update Remaining ---
async function updateRemaining(){
  if(!roomRef) return;
  const snapshot = await roomRef.collection('entries').where('in_play','==',true).get();
  const remaining = snapshot.size;
  document.getElementById('remaining').innerText = remaining;
  document.getElementById('playCard').style.display = remaining>0 ? 'block' : 'none';
  return remaining;
}
</script>
</body>
</html>

