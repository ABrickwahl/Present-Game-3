<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Xmas Bitches</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Indie+Flower&family=Caveat&family=Lobster&family=Roboto&display=swap" rel="stylesheet">

<style>
/* --- Dark Cards on Mostly-White Xmas Background --- */
body {
  font-family: Roboto, sans-serif;
  background-color: #f5f5f5;  /* fallback if image fails */
  background-repeat: no-repeat;
  background-position: center center;
  background-attachment: fixed;
  background-size: cover;
  color: #fff;
  padding: 20px;
  margin: 0;
}

h1 {
  margin-bottom: 10px;
  color: #000;
  text-shadow: 1px 1px 2px #fff;
  text-align: center;
}

.card {
  background: rgba(20,20,20,0.88);
  padding: 15px;
  border-radius: 10px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  margin-bottom: 15px;
  color: #fff;
}

input, select, button {
  padding: 8px;
  margin: 5px 0;
  border-radius: 5px;
  border: none;
  font-size: 16px;
}

input, select {
  background: #444;
  color: #fff;
  width: 100%;
  box-sizing: border-box;
}

button {
  cursor: pointer;
  background: #d9534f;
  color: #fff;
  border: none;
  width: 100%;
}

button:hover { background: #c9302c; }
button:disabled { opacity: 0.55; cursor: not-allowed; }

/* âœ… FIX: canvas is not huge anymore */
canvas{
  border: 1px solid #ccc;
  border-radius: 6px;
  background: #fff;
  touch-action: none;

  display: block;
  width: 320px;
  max-width: 100%;
  height: 160px;
  margin: 10px auto;
}

.entry-card {
  font-size: 26px;
  text-align: center;
  margin: 15px 0;
  color: #ffd700;
}

.done { color: #28a745; font-weight: bold; }

#winnerCard {
  display: none;
  background: rgba(255,215,0,0.9);
  color: #000;
  font-size: 24px;
  font-weight: bold;
  text-align: center;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.7);
}

/* Feedback box */
#feedbackBox {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(-20px);
  z-index: 9999;
  display: none;
  text-align: center;
  font-size: 20px;
  font-weight: bold;
  padding: 10px 20px;
  border-radius: 8px;
  background-color: #28a745;
  color: #fff;
  opacity: 0;
  transition: all 0.4s ease;
}
#feedbackBox.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* Turn banner */
#turnBanner{
  text-align:center;
  font-weight:bold;
  font-size:18px;
}
</style>
</head>

<body>
<h1>ðŸŽ„ 2025 Presents to Present ðŸŽ„</h1>

<div id="feedbackBox"></div>

<!-- Room Join -->
<div class="card" id="roomCard">
  <h3>Create or Join Room</h3>
  <input id="playerName" placeholder="Your name" />
  <input id="roomId" placeholder="Room code" />
  <button onclick="joinRoom()">Join Room</button>
</div>

<!-- Room Info -->
<div class="card" id="roomInfoCard" style="display:none;">
  <h3>Room Code: <span id="displayRoomCode"></span></h3>
  <button onclick="copyRoomCode()">Copy Room Code</button>
</div>

<!-- Players List -->
<div class="card" id="gameCard" style="display:none;">
  <h3>Players</h3>
  <ul id="players"></ul>
</div>

<!-- Add Entry -->
<div class="card" id="entryCard" style="display:none;">
  <h3>Add Entry</h3>
  <select id="entryAuthor"></select><br />
  <input id="entryText" placeholder="Enter text" />
  <select id="style" onchange="toggleTextInput()">
    <option value="font">Random Font</option>
    <option value="handwriting">Handwriting</option>
  </select><br />
  <canvas id="canvas"></canvas><br />
  <button onclick="clearCanvas()">Clear Drawing</button>
  <button id="addEntryBtn" onclick="addEntry()">Add Entry</button>
</div>

<!-- Turn Info -->
<div class="card" id="turnCard" style="display:none;">
  <div id="turnBanner">Turn: <span id="turnPlayer">â€”</span></div>
  <div style="text-align:center; font-size:14px; opacity:0.9; margin-top:6px;">
    Each player gets <b>one guess</b> per turn.
  </div>
</div>

<!-- Game Play -->
<div class="card" id="playCard" style="display:none;">
  <h3>Game</h3>

  <button id="drawBtn" onclick="drawEntry()">Draw Random Entry</button>

  <!-- âœ… Waiting message w/ rotating cry synonym -->
  <div id="waitingMsg" style="text-align:center; font-size:16px; opacity:0.9; margin:10px 0; display:none;">
    Waiting for <b><span id="waitingFor">â€”</span></b> to <b><span id="waitingVerb">sob</span></b>...
  </div>

  <div id="entry"></div>

  <select id="guess"></select>
  <button id="guessBtn" onclick="submitGuess()">Guess</button>
</div>

<!-- Remaining Entries -->
<div class="card" id="remainingCard" style="display:none;">
  Remaining entries: <span id="remaining">0</span>
</div>

<!-- Winner Display -->
<div id="winnerCard"></div>

<script>
/* -----------------------------
   Random mostly-white Xmas background
------------------------------ */
const xmasBackgrounds = [
  "https://images.unsplash.com/photo-1608889175250-c3b0c166c4f3?auto=format&fit=crop&w=1920&q=80",
  "https://images.unsplash.com/photo-1543589077-47d81606c1bf?auto=format&fit=crop&w=1920&q=80",
  "https://images.unsplash.com/photo-1512389098783-66b81f86e199?auto=format&fit=crop&w=1920&q=80",
  "https://images.unsplash.com/photo-1545608444-f045a6db6133?auto=format&fit=crop&w=1920&q=80",
  "https://images.unsplash.com/photo-1608231387042-66d1773070a5?auto=format&fit=crop&w=1920&q=80"
];
document.body.style.backgroundImage =
  `url('${xmasBackgrounds[Math.floor(Math.random()*xmasBackgrounds.length)]}')`;

/* -----------------------------
   Firebase
------------------------------ */
const firebaseConfig = {
  apiKey: "AIzaSyBcfYtibV2vzCG_rchAX8KqUnfJNbnpyQM",
  authDomain: "xmas-guessing-game-e744e.firebaseapp.com",
  projectId: "xmas-guessing-game-e744e",
  storageBucket: "xmas-guessing-game-e744e.firebasestorage.app",
  messagingSenderId: "324648115760",
  appId: "1:324648115760:web:c51e7284128906138ad7f5",
  measurementId: "G-XL91BHP4P4"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

/* -----------------------------
   Cry synonyms (rotating while waiting)
------------------------------ */
const crySynonyms = [
  "cry","sob","weep","wail","bawl","snivel","whimper","blubber","lament"
];
let waitingInterval = null;

function setRandomWaitingVerb(){
  const w = crySynonyms[Math.floor(Math.random()*crySynonyms.length)];
  const el = document.getElementById('waitingVerb');
  if(el) el.textContent = w;
}
function startWaitingVerbRotation(){
  stopWaitingVerbRotation();
  setRandomWaitingVerb();
  waitingInterval = setInterval(setRandomWaitingVerb, 1500);
}
function stopWaitingVerbRotation(){
  if(waitingInterval) clearInterval(waitingInterval);
  waitingInterval = null;
}

/* -----------------------------
   State
------------------------------ */
let roomRef;
let playerName = '';
let roomId = '';
const fonts = ['Pacifico','Indie Flower','Caveat','Lobster','Roboto'];
let currentEntry = null;

/* -----------------------------
   Canvas setup (fixed size + crisp drawing)
------------------------------ */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvasToFixed(){
  // Match CSS: 320x160 (but keep crisp on high DPI)
  const cssW = 320;
  const cssH = 160;
  const dpr = window.devicePixelRatio || 1;

  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);

  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // White background
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, cssW, cssH);

  // Default stroke style
  ctx.strokeStyle = "#000";
}
resizeCanvasToFixed();

let drawing = false;

// Desktop drawing
canvas.addEventListener('mousedown', () => drawing = true);
canvas.addEventListener('mouseup', () => { drawing = false; ctx.beginPath(); });
canvas.addEventListener('mousemove', draw);

// Mobile drawing
canvas.addEventListener('touchstart', e => { e.preventDefault(); drawing = true; drawTouch(e); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); drawTouch(e); });
canvas.addEventListener('touchend', e => { e.preventDefault(); drawing = false; ctx.beginPath(); });

function draw(e) {
  if(!drawing) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  ctx.lineWidth = 2;
  ctx.lineCap = 'round';
  ctx.lineTo(x, y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y);
}
function drawTouch(e) {
  if(!drawing) return;
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;

  ctx.lineWidth = 2;
  ctx.lineCap = 'round';
  ctx.lineTo(x, y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y);
}
function clearCanvas() {
  // Clear to white in CSS coordinates (320x160)
  ctx.clearRect(0, 0, 320, 160);
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, 320, 160);
}

/* -----------------------------
   UI Helpers
------------------------------ */
function toggleTextInput(){
  const style = document.getElementById('style').value;
  document.getElementById('entryText').disabled = (style === 'handwriting');
}

function showFeedback(message,color){
  const fb = document.getElementById('feedbackBox');
  fb.textContent = message;
  fb.style.backgroundColor = color;
  fb.style.color = '#fff';
  fb.classList.add('show');
  fb.style.display = 'block';
  setTimeout(()=>{ fb.classList.remove('show'); }, 2000);
}

function copyRoomCode() {
  navigator.clipboard.writeText(roomId)
    .then(() => alert('Room code copied!'))
    .catch(()=>alert('Failed to copy.'));
}

function sortedPlayerNames(playersObj){
  return Object.keys(playersObj || {}).sort((a,b)=>a.localeCompare(b));
}

function renderCurrentEntry(entry){
  const div = document.getElementById('entry');
  div.innerHTML = '';
  if(!entry) return;

  if(entry.style === 'handwriting'){
    const img = document.createElement('img');
    img.src = entry.image;
    img.width = 300;
    div.appendChild(img);
  } else {
    const p = document.createElement('div');
    p.className = 'entry-card';
    p.style.fontFamily = entry.font;
    p.textContent = entry.text;
    div.appendChild(p);
  }
}

/* -----------------------------
   Turn State Initialization
------------------------------ */
async function ensureTurnStateExists(){
  await db.runTransaction(async (tx) => {
    const snap = await tx.get(roomRef);
    const data = snap.data() || {};
    const players = data.players || {};
    const order = sortedPlayerNames(players);

    if(!data.turnOrder || typeof data.turnIndex !== 'number'){
      tx.set(roomRef, {
        turnOrder: order,
        turnIndex: 0,
        currentEntryId: null
      }, { merge:true });
      return;
    }

    const existing = Array.isArray(data.turnOrder) ? data.turnOrder : [];
    const same = existing.length === order.length && existing.every((v,i)=>v===order[i]);
    if(!same){
      const currentName = existing[data.turnIndex] ?? existing[0] ?? null;
      let newIndex = 0;
      if(currentName){
        const idx = order.indexOf(currentName);
        newIndex = (idx >= 0) ? idx : 0;
      }
      tx.set(roomRef, { turnOrder: order, turnIndex: newIndex }, { merge:true });
    }
  });
}

/* -----------------------------
   Join Room
------------------------------ */
async function joinRoom() {
  playerName = document.getElementById('playerName').value.trim();
  roomId = document.getElementById('roomId').value.trim();
  if(!playerName || !roomId) return alert('Enter name and room code');

  roomRef = db.collection('games').doc(roomId);

  await roomRef.set({ players: { [playerName]: {count:0, score:0} } }, { merge:true });

  document.getElementById('roomCard').style.display = 'none';
  document.getElementById('roomInfoCard').style.display = 'block';
  document.getElementById('displayRoomCode').textContent = roomId;

  document.getElementById('gameCard').style.display = 'block';
  document.getElementById('entryCard').style.display = 'block';
  document.getElementById('turnCard').style.display = 'block';
  document.getElementById('playCard').style.display = 'block';
  document.getElementById('remainingCard').style.display = 'block';

  await ensureTurnStateExists();
  listenUpdates();
}

/* -----------------------------
   Live Updates
   âœ… Only the turn player can SEE the entry.
   âœ… Waiting verb rotates (cry synonyms) for non-turn players.
------------------------------ */
function listenUpdates() {
  roomRef.onSnapshot(async (snapshot) => {
    const data = snapshot.data() || {};
    updatePlayersList(data.players || {});
    await updateRemaining();

    const order = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(data.players || {});
    const turnIndex = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
    const currentTurnPlayer = order[turnIndex] || 'â€”';

    document.getElementById('turnPlayer').textContent = currentTurnPlayer;

    const isMyTurn = (currentTurnPlayer === playerName);

    document.getElementById('drawBtn').disabled = !isMyTurn;
    document.getElementById('guessBtn').disabled = !isMyTurn;
    document.getElementById('guess').disabled = !isMyTurn;

    document.getElementById('waitingFor').textContent = currentTurnPlayer;

    if(!isMyTurn){
      document.getElementById('waitingMsg').style.display = 'block';
      startWaitingVerbRotation();

      // ðŸ”’ Hide entry for everyone else
      document.getElementById('entry').innerHTML = '';
      currentEntry = null;
      return; // IMPORTANT: do not fetch/render entry for non-turn players
    } else {
      document.getElementById('waitingMsg').style.display = 'none';
      stopWaitingVerbRotation();
    }

    // Turn player ONLY: fetch + render shared currentEntryId (if any)
    if(data.currentEntryId){
      const entryDoc = await roomRef.collection('entries').doc(data.currentEntryId).get();
      if(entryDoc.exists){
        currentEntry = { id: entryDoc.id, ...entryDoc.data() };
        renderCurrentEntry(currentEntry);
      } else {
        currentEntry = null;
        document.getElementById('entry').innerHTML = '';
      }
    } else {
      currentEntry = null;
      document.getElementById('entry').innerHTML = '';
    }
  });
}

/* -----------------------------
   Players UI
------------------------------ */
function updatePlayersList(players){
  const list = document.getElementById('players');
  list.innerHTML = '';

  const authorSelect = document.getElementById('entryAuthor');
  const guessSelect = document.getElementById('guess');
  authorSelect.innerHTML = '';
  guessSelect.innerHTML = '';

  for(const p in players){
    const li = document.createElement('li');
    li.textContent = `${p} (${players[p].count || 0}/3, score: ${players[p].score || 0})`;
    if((players[p].count||0) >= 3) li.className = 'done';
    list.appendChild(li);

    const o1 = document.createElement('option'); o1.value=p; o1.textContent=p; authorSelect.appendChild(o1);
    const o2 = document.createElement('option'); o2.value=p; o2.textContent=p; guessSelect.appendChild(o2);
  }
}

/* -----------------------------
   Add Entry
------------------------------ */
async function addEntry() {
  const text = document.getElementById('entryText').value.trim();
  const author = document.getElementById('entryAuthor').value;
  const style = document.getElementById('style').value;

  if(!author) return showFeedback('Select an author','red');
  if(style === 'font' && !text) return showFeedback('Enter text for font style','red');

  const playerDoc = await roomRef.get();
  const players = (playerDoc.data() || {}).players || {};
  if((players[author]?.count || 0) >= 3) return showFeedback(`${author} already entered 3 items`,'red');

  const entry = { author, style, in_play:true, guessed_correctly:false };

  if(style === 'handwriting') entry.image = canvas.toDataURL();
  else {
    entry.text = text;
    entry.font = fonts[Math.floor(Math.random()*fonts.length)];
  }

  await roomRef.collection('entries').doc().set(entry);
  await roomRef.update({ [`players.${author}.count`]: (players[author]?.count||0)+1 });

  clearCanvas();
  document.getElementById('entryText').value = '';
  await updateRemaining();
}

/* -----------------------------
   Draw Entry
   âœ… Only current turn player can draw.
   âœ… If you draw YOUR OWN entry, you may press draw again (redraw).
   âœ… If you drew someone else's entry, you cannot redraw.
   âœ… Prefers not to pick your own entry when others exist.
------------------------------ */
async function drawEntry() {
  // A) Validate it's your turn; if already drawn, only allow redraw if the drawn entry is yours
  try{
    await db.runTransaction(async (tx) => {
      const roomSnap = await tx.get(roomRef);
      const data = roomSnap.data() || {};
      const players = data.players || {};
      const order = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(players);
      const idx = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
      const turnPlayer = order[idx];

      if(turnPlayer !== playerName) throw new Error("Not your turn");

      if(data.currentEntryId){
        const entryRef = roomRef.collection('entries').doc(data.currentEntryId);
        const entrySnap = await tx.get(entryRef);
        if(!entrySnap.exists) throw new Error("Current entry missing");

        const entryData = entrySnap.data() || {};
        if(entryData.author !== playerName){
          throw new Error("You can only redraw if you drew your own entry");
        }
      }
    });
  } catch(err){
    return showFeedback(err.message || "Cannot draw now", "#d9534f");
  }

  // B) Choose an entry (prefer not your own if possible)
  const snap = await roomRef.collection('entries').where('in_play','==',true).get();
  const entries = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  if(entries.length === 0) return showFeedback("No entries left", "red");

  const nonSelf = entries.filter(e => e.author !== playerName);
  const pool = (nonSelf.length > 0) ? nonSelf : entries;
  const picked = pool[Math.floor(Math.random()*pool.length)];

  // C) Commit it (still your turn; overwrite allowed only if previous was yours)
  try{
    await db.runTransaction(async (tx) => {
      const roomSnap = await tx.get(roomRef);
      const data = roomSnap.data() || {};
      const players = data.players || {};
      const order = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(players);
      const idx = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
      const turnPlayer = order[idx];

      if(turnPlayer !== playerName) throw new Error("Not your turn");

      if(data.currentEntryId){
        const entryRef = roomRef.collection('entries').doc(data.currentEntryId);
        const entrySnap = await tx.get(entryRef);
        if(!entrySnap.exists) throw new Error("Current entry missing");
        const entryData = entrySnap.data() || {};
        if(entryData.author !== playerName){
          throw new Error("You can only redraw if you drew your own entry");
        }
      }

      tx.set(roomRef, { currentEntryId: picked.id }, { merge:true });
    });

    if(picked.author === playerName){
      showFeedback("You drew your own â€” tap Draw again to redraw âœ…", "#f0ad4e");
    }
  } catch(err){
    return showFeedback(err.message || "Draw failed", "#d9534f");
  }
}

/* -----------------------------
   Submit Guess
   âœ… ONE guess, then turn advances automatically.
   âœ… Only the current turn player can guess.
------------------------------ */
async function submitGuess() {
  const guess = document.getElementById('guess').value;
  if(!guess) return;

  const roomSnap = await roomRef.get();
  const roomData = roomSnap.data() || {};
  if(!roomData.currentEntryId) return showFeedback('Draw an entry first','#d9534f');

  const order = Array.isArray(roomData.turnOrder) ? roomData.turnOrder : sortedPlayerNames(roomData.players || {});
  const idx = (typeof roomData.turnIndex === 'number') ? roomData.turnIndex : 0;
  const turnPlayer = order[idx];
  if(turnPlayer !== playerName) return showFeedback("Not your turn", "#d9534f");

  const entryDoc = await roomRef.collection('entries').doc(roomData.currentEntryId).get();
  if(!entryDoc.exists) return showFeedback('Entry missing','#d9534f');

  currentEntry = { id: entryDoc.id, ...entryDoc.data() };
  const wasCorrect = (guess === currentEntry.author);

  try{
    await db.runTransaction(async (tx) => {
      const snap = await tx.get(roomRef);
      const data = snap.data() || {};
      const players = data.players || {};
      const order2 = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(players);
      const idx2 = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
      const turnPlayer2 = order2[idx2];

      if(turnPlayer2 !== playerName) throw new Error("Not your turn");
      if(!data.currentEntryId) throw new Error("No entry drawn");

      const myScore = players[playerName]?.score || 0;

      if(wasCorrect){
        tx.update(roomRef, { [`players.${playerName}.score`]: myScore + 1 });
        tx.update(roomRef.collection('entries').doc(data.currentEntryId), { guessed_correctly:true, in_play:false });
      }

      const next = (idx2 + 1) % (order2.length || 1);
      tx.set(roomRef, { turnIndex: next, currentEntryId: null }, { merge:true });
    });
  } catch(err){
    return showFeedback(err.message || 'Guess failed', '#d9534f');
  }

  showFeedback(wasCorrect ? 'âœ… Correct!' : 'âŒ Wrong!', wasCorrect ? '#28a745' : '#d9534f');

  // Winner check
  const allEntries = await roomRef.collection('entries').get();
  const remaining = allEntries.docs.filter(doc => !doc.data().guessed_correctly);
  if(remaining.length === 0){
    const finalPlayers = (await roomRef.get()).data().players || {};
    let maxScore = -1, winners = [];
    for(const p in finalPlayers){
      const s = finalPlayers[p].score || 0;
      if(s > maxScore){ maxScore = s; winners = [p]; }
      else if(s === maxScore) winners.push(p);
    }
    document.getElementById('winnerCard').style.display='block';
    document.getElementById('winnerCard').textContent =
      `ðŸŽ‰ Winner: ${winners.join(', ')} with ${maxScore} points! ðŸŽ‰`;
    document.getElementById('playCard').style.display='none';
  }

  currentEntry = null;
  document.getElementById('entry').innerHTML = '';
  await updateRemaining();
}

/* -----------------------------
   Remaining
------------------------------ */
async function updateRemaining(){
  if(!roomRef) return 0;
  const snap = await roomRef.collection('entries').where('in_play','==',true).get();
  const remaining = snap.size;
  document.getElementById('remaining').innerText = remaining;
  return remaining;
}
</script>
</body>
</html>
