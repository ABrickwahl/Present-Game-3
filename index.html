<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Xmas Bitches</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Indie+Flower&family=Caveat&family=Lobster&family=Roboto&display=swap" rel="stylesheet">
<style>
body { 
  font-family: Roboto, sans-serif; 
  background: url('https://i.ibb.co/0Z6M95Z/xmas-background.jpg') no-repeat center center fixed; 
  background-size: cover; 
  color: #fff; 
  padding:20px; 
  margin:0;
}
h1 { 
  margin-bottom:10px; 
  color:#000;
  text-shadow: 1px 1px 2px #fff; 
  text-align:center; 
}
.card { 
  background: rgba(30,30,30,0.85); 
  padding:15px; 
  border-radius:10px; 
  box-shadow:0 4px 10px rgba(0,0,0,0.5); 
  margin-bottom:15px; 
  color:#fff;
}
input, select, button { padding:8px; margin:5px 0; border-radius:5px; border:none; font-size:16px; }
input, select { background:#444; color:#fff; width:100%; box-sizing:border-box; }
button { cursor:pointer; background:#d9534f; color:#fff; border:none; width:100%; }
button:hover { background:#c9302c; }
button:disabled { opacity:0.55; cursor:not-allowed; }
canvas { border:1px solid #ccc; border-radius:6px; background:#fff; touch-action:none; width:100%; height:auto; }
.entry-card { font-size:26px; text-align:center; margin:15px 0; color:#ffd700; }
.done { color: #28a745; font-weight: bold; }
#winnerCard { display:none; background: rgba(255,215,0,0.9); color:#000; font-size:24px; font-weight:bold; text-align:center; padding:20px; border-radius:10px; box-shadow:0 4px 10px rgba(0,0,0,0.7); }

#feedbackBox {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(-20px);
  z-index: 9999;
  display: none;
  text-align: center;
  font-size: 20px;
  font-weight: bold;
  padding: 10px 20px;
  border-radius: 8px;
  background-color: #28a745;
  color: #fff;
  opacity: 0;
  transition: all 0.4s ease;
}
#feedbackBox.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

#turnBanner{
  text-align:center;
  font-weight:bold;
  font-size:18px;
}
</style>
</head>
<body>

<h1>ðŸŽ„ 2025 Presents to Present ðŸŽ„</h1>

<div id="feedbackBox"></div>

<div class="card" id="roomCard">
  <h3>Create or Join Room</h3>
  <input id="playerName" placeholder="Your name" />
  <input id="roomId" placeholder="Room code" />
  <button onclick="joinRoom()">Join Room</button>
</div>

<div class="card" id="roomInfoCard" style="display:none;">
  <h3>Room Code: <span id="displayRoomCode"></span></h3>
  <button onclick="copyRoomCode()">Copy Room Code</button>
</div>

<div class="card" id="gameCard" style="display:none;">
  <h3>Players</h3>
  <ul id="players"></ul>
</div>

<div class="card" id="entryCard" style="display:none;">
  <h3>Add Entry</h3>
  <select id="entryAuthor"></select><br />
  <input id="entryText" placeholder="Enter text" />
  <select id="style" onchange="toggleTextInput()">
    <option value="font">Random Font</option>
    <option value="handwriting">Handwriting</option>
  </select><br />
  <canvas id="canvas" width="300" height="150"></canvas><br />
  <button onclick="clearCanvas()">Clear Drawing</button>
  <button id="addEntryBtn" onclick="addEntry()">Add Entry</button>
</div>

<!-- Turn Info -->
<div class="card" id="turnCard" style="display:none;">
  <div id="turnBanner">Turn: <span id="turnPlayer">â€”</span></div>
  <div style="text-align:center; font-size:14px; opacity:0.9; margin-top:6px;">
    Each player gets <b>one guess</b> per turn.
  </div>
</div>

<div class="card" id="playCard" style="display:none;">
  <h3>Game</h3>
  <button id="drawBtn" onclick="drawEntry()">Draw Random Entry</button>
  <div id="entry"></div>
  <select id="guess"></select>
  <button id="guessBtn" onclick="submitGuess()">Guess</button>
</div>

<div class="card" id="remainingCard" style="display:none;">
  Remaining entries: <span id="remaining">0</span>
</div>

<div id="winnerCard"></div>

<script>
// --- Firebase config ---
const firebaseConfig = {
  apiKey: "AIzaSyBcfYtibV2vzCG_rchAX8KqUnfJNbnpyQM",
  authDomain: "xmas-guessing-game-e744e.firebaseapp.com",
  projectId: "xmas-guessing-game-e744e",
  storageBucket: "xmas-guessing-game-e744e.firebasestorage.app",
  messagingSenderId: "324648115760",
  appId: "1:324648115760:web:c51e7284128906138ad7f5",
  measurementId: "G-XL91BHP4P4"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

let roomRef;
let playerName = '';
let roomId = '';
const fonts = ['Pacifico','Indie Flower','Caveat','Lobster','Roboto'];
let currentEntry = null;

// --- Canvas setup ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.fillStyle = "white";
ctx.fillRect(0, 0, canvas.width, canvas.height);
let drawing = false;

canvas.addEventListener('mousedown', () => drawing = true);
canvas.addEventListener('mouseup', () => { drawing = false; ctx.beginPath(); });
canvas.addEventListener('mousemove', draw);

canvas.addEventListener('touchstart', e => { e.preventDefault(); drawing = true; drawTouch(e); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); drawTouch(e); });
canvas.addEventListener('touchend', e => { e.preventDefault(); drawing = false; ctx.beginPath(); });

function draw(e) {
  if(!drawing) return;
  const rect = canvas.getBoundingClientRect();
  ctx.lineWidth = 2; ctx.lineCap = 'round';
  ctx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
}
function drawTouch(e) {
  if(!drawing) return;
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  ctx.lineWidth = 2; ctx.lineCap = 'round';
  ctx.lineTo(touch.clientX - rect.left, touch.clientY - rect.top);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(touch.clientX - rect.left, touch.clientY - rect.top);
}
function clearCanvas() { 
  ctx.clearRect(0,0,canvas.width,canvas.height); 
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function toggleTextInput(){
  const style = document.getElementById('style').value;
  document.getElementById('entryText').disabled = (style==='handwriting');
}

// --- Feedback ---
function showFeedback(message,color){
  const fb = document.getElementById('feedbackBox');
  fb.textContent = message;
  fb.style.backgroundColor = color;
  fb.style.color = '#fff';
  fb.classList.add('show');
  fb.style.display='block';
  setTimeout(()=>{ fb.classList.remove('show'); },2000);
}

// --- Helpers for Turn System ---
function sortedPlayerNames(playersObj){
  return Object.keys(playersObj || {}).sort((a,b)=>a.localeCompare(b));
}

async function ensureTurnStateExists(){
  // Create turn state if missing:
  // turnOrder: [names], turnIndex: 0, currentEntryId: null, lockedAt: serverTimestamp
  await db.runTransaction(async (tx) => {
    const snap = await tx.get(roomRef);
    const data = snap.data() || {};
    const players = data.players || {};
    const order = sortedPlayerNames(players);

    // If no turn state exists, initialize it
    if(!data.turnOrder || typeof data.turnIndex !== 'number'){
      tx.set(roomRef, {
        turnOrder: order,
        turnIndex: 0,
        currentEntryId: null
      }, { merge:true });
      return;
    }

    // Keep turnOrder in sync if players changed (stable + deterministic)
    const existing = Array.isArray(data.turnOrder) ? data.turnOrder : [];
    const same = existing.length === order.length && existing.every((v,i)=>v===order[i]);
    if(!same){
      // Preserve current player name if possible
      const currentName = existing[data.turnIndex] ?? existing[0] ?? null;
      let newIndex = 0;
      if(currentName){
        const idx = order.indexOf(currentName);
        newIndex = (idx >= 0) ? idx : 0;
      }
      tx.set(roomRef, { turnOrder: order, turnIndex: newIndex }, { merge:true });
    }
  });
}

async function advanceTurn(){
  await db.runTransaction(async (tx) => {
    const snap = await tx.get(roomRef);
    const data = snap.data() || {};
    const order = Array.isArray(data.turnOrder) ? data.turnOrder : [];
    if(order.length === 0) return;

    const idx = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
    const next = (idx + 1) % order.length;

    // advancing turn always clears the current entry so the next player draws fresh
    tx.set(roomRef, {
      turnIndex: next,
      currentEntryId: null
    }, { merge:true });
  });
}

// --- Join Room ---
async function joinRoom() {
  playerName = document.getElementById('playerName').value.trim();
  roomId = document.getElementById('roomId').value.trim();
  if(!playerName || !roomId) return alert('Enter name and room code');

  roomRef = db.collection('games').doc(roomId);

  // Merge player into players map
  await roomRef.set({ players: {[playerName]: {count:0, score:0}} }, { merge:true });

  document.getElementById('roomCard').style.display='none';
  document.getElementById('roomInfoCard').style.display='block';
  document.getElementById('displayRoomCode').textContent = roomId;

  document.getElementById('gameCard').style.display='block';
  document.getElementById('entryCard').style.display='block';
  document.getElementById('turnCard').style.display='block';
  document.getElementById('remainingCard').style.display='block';

  await ensureTurnStateExists();
  listenUpdates();
}

// Copy room code
function copyRoomCode() {
  navigator.clipboard.writeText(roomId)
    .then(() => alert('Room code copied!'))
    .catch(()=>alert('Failed to copy.'));
}

// --- Firebase Listeners ---
function listenUpdates() {
  roomRef.onSnapshot(async (snapshot) => {
    const data = snapshot.data() || {};
    updatePlayersList(data.players || {});
    await updateRemaining();

    // Update turn UI and enable/disable guessing based on whose turn it is
    const order = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(data.players);
    const turnIndex = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
    const currentTurnPlayer = order[turnIndex] || 'â€”';

    document.getElementById('turnPlayer').textContent = currentTurnPlayer;

    const isMyTurn = (currentTurnPlayer === playerName);

    // Enable draw/guess only if it is your turn AND there are entries left AND game not won
    document.getElementById('drawBtn').disabled = !isMyTurn;
    document.getElementById('guessBtn').disabled = !isMyTurn;

    // If it becomes not your turn, clear local current entry display
    if(!isMyTurn){
      currentEntry = null;
      document.getElementById('entry').innerHTML = '';
    }

    // If a currentEntryId exists, load and display it for everyone
    if(data.currentEntryId){
      const entryDoc = await roomRef.collection('entries').doc(data.currentEntryId).get();
      if(entryDoc.exists){
        currentEntry = { id: entryDoc.id, ...entryDoc.data() };
        renderCurrentEntry(currentEntry);
      }
    }
  });
}

// --- Render entry (shared) ---
function renderCurrentEntry(entry){
  const div = document.getElementById('entry');
  div.innerHTML = '';

  if(!entry) return;

  if(entry.style==='handwriting'){
    const img = document.createElement('img');
    img.src = entry.image;
    img.width = 300;
    div.appendChild(img);
  } else {
    const p = document.createElement('div');
    p.className='entry-card';
    p.style.fontFamily = entry.font;
    p.textContent = entry.text;
    div.appendChild(p);
  }
}

// --- Update Players ---
function updatePlayersList(players){
  const list = document.getElementById('players');
  list.innerHTML='';
  const authorSelect = document.getElementById('entryAuthor');
  const guessSelect = document.getElementById('guess');
  authorSelect.innerHTML=''; guessSelect.innerHTML='';

  for(const p in players){
    const li = document.createElement('li');
    li.textContent = `${p} (${players[p].count || 0}/3, score: ${players[p].score || 0})`;
    if((players[p].count||0) >= 3) li.className='done';
    list.appendChild(li);

    const o1 = document.createElement('option'); o1.value=p; o1.textContent=p; authorSelect.appendChild(o1);
    const o2 = document.createElement('option'); o2.value=p; o2.textContent=p; guessSelect.appendChild(o2);
  }
}

// --- Add Entry ---
async function addEntry() {
  const text = document.getElementById('entryText').value.trim();
  const author = document.getElementById('entryAuthor').value;
  const style = document.getElementById('style').value;

  if(!author) return showFeedback('Select an author','red');
  if(style === 'font' && !text) return showFeedback('Enter text for font style','red');

  const playerDoc = await roomRef.get();
  const players = (playerDoc.data() || {}).players || {};
  if((players[author]?.count || 0) >= 3) return showFeedback(`${author} already entered 3 items`,'red');

  const entry = { author, style, in_play:true, guessed_correctly:false };
  if(style==='handwriting') entry.image = canvas.toDataURL();
  else {
    entry.text = text;
    entry.font = fonts[Math.floor(Math.random()*fonts.length)];
  }

  await roomRef.collection('entries').doc().set(entry);
  await roomRef.update({ [`players.${author}.count`]: (players[author]?.count||0)+1 });

  clearCanvas();
  document.getElementById('entryText').value='';
  await updateRemaining();
}

// --- Draw Entry (ONLY current turn player can press, but we enforce in Firestore too) ---
async function drawEntry() {
  // Transaction: ensure it's my turn and there isn't already an active currentEntryId
  await db.runTransaction(async (tx) => {
    const roomSnap = await tx.get(roomRef);
    const data = roomSnap.data() || {};
    const players = data.players || {};
    const order = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(players);
    const idx = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
    const turnPlayer = order[idx];

    if(turnPlayer !== playerName) throw new Error("Not your turn");
    if(data.currentEntryId) throw new Error("Entry already drawn");

    // fetch in-play entries (not possible directly in tx), so we do a simple query outside tx:
  }).catch(err => {
    showFeedback(err.message || 'Cannot draw now','#d9534f');
    return;
  });

  // Outside tx: pick an entry
  const snapshot = await roomRef.collection('entries').where('in_play','==',true).get();
  const entries = snapshot.docs.map(doc => ({id: doc.id, ...doc.data()}));
  if(entries.length===0) return showFeedback('No entries left','red');

  const picked = entries[Math.floor(Math.random()*entries.length)];

  // Commit chosen entry as the shared current entry, but only if still my turn and still empty
  await db.runTransaction(async (tx) => {
    const roomSnap = await tx.get(roomRef);
    const data = roomSnap.data() || {};
    const players = data.players || {};
    const order = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(players);
    const idx = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
    const turnPlayer = order[idx];

    if(turnPlayer !== playerName) throw new Error("Not your turn");
    if(data.currentEntryId) throw new Error("Entry already drawn");

    tx.set(roomRef, { currentEntryId: picked.id }, { merge:true });
  });

  // local render will happen from snapshot listener
}

// --- Submit Guess (ONE guess then auto-advance turn) ---
async function submitGuess() {
  const guess = document.getElementById('guess').value;
  if(!guess) return;

  // Only allow if there is a current entry (shared) and it's your turn
  const roomSnap = await roomRef.get();
  const roomData = roomSnap.data() || {};
  if(!roomData.currentEntryId) return showFeedback('Draw an entry first','#d9534f');

  const order = Array.isArray(roomData.turnOrder) ? roomData.turnOrder : sortedPlayerNames(roomData.players || {});
  const idx = (typeof roomData.turnIndex === 'number') ? roomData.turnIndex : 0;
  const turnPlayer = order[idx];

  if(turnPlayer !== playerName) return showFeedback("Not your turn",'#d9534f');

  const entryDoc = await roomRef.collection('entries').doc(roomData.currentEntryId).get();
  if(!entryDoc.exists) return showFeedback('Entry missing','#d9534f');

  currentEntry = { id: entryDoc.id, ...entryDoc.data() };

  let wasCorrect = (guess === currentEntry.author);

  // Apply result + advance turn atomically
  await db.runTransaction(async (tx) => {
    const snap = await tx.get(roomRef);
    const data = snap.data() || {};
    const players = data.players || {};
    const order2 = Array.isArray(data.turnOrder) ? data.turnOrder : sortedPlayerNames(players);
    const idx2 = (typeof data.turnIndex === 'number') ? data.turnIndex : 0;
    const turnPlayer2 = order2[idx2];

    if(turnPlayer2 !== playerName) throw new Error("Not your turn");
    if(!data.currentEntryId) throw new Error("No entry drawn");

    const myScore = players[playerName]?.score || 0;

    // If correct: score + mark entry done
    if(wasCorrect){
      tx.update(roomRef, { [`players.${playerName}.score`]: myScore + 1 });
      tx.update(roomRef.collection('entries').doc(data.currentEntryId), { guessed_correctly:true, in_play:false });
    }

    // Advance turn and clear currentEntryId regardless (ONE guess)
    const next = (idx2 + 1) % (order2.length || 1);
    tx.set(roomRef, { turnIndex: next, currentEntryId: null }, { merge:true });
  }).catch(err => {
    showFeedback(err.message || 'Guess failed','#d9534f');
    return;
  });

  if(wasCorrect) showFeedback('âœ… Correct!','#28a745');
  else showFeedback('âŒ Wrong!','#d9534f');

  // Check winner after move (non-transaction ok)
  const allEntries = await roomRef.collection('entries').get();
  const remaining = allEntries.docs.filter(doc=>!doc.data().guessed_correctly);
  if(remaining.length===0){
    const finalPlayers = (await roomRef.get()).data().players || {};
    let maxScore=-1, winners=[];
    for(const p in finalPlayers){
      const s = finalPlayers[p].score || 0;
      if(s>maxScore){ maxScore=s; winners=[p]; }
      else if(s===maxScore) winners.push(p);
    }
    document.getElementById('winnerCard').style.display='block';
    document.getElementById('winnerCard').textContent = `ðŸŽ‰ Winner: ${winners.join(', ')} with ${maxScore} points! ðŸŽ‰`;
    document.getElementById('playCard').style.display='none';
  }

  // clear local display; next player will draw
  currentEntry = null;
  document.getElementById('entry').innerHTML='';
  await updateRemaining();
}

// --- Update Remaining ---
async function updateRemaining(){
  if(!roomRef) return;
  const snapshot = await roomRef.collection('entries').where('in_play','==',true).get();
  const remaining = snapshot.size;
  document.getElementById('remaining').innerText = remaining;
  document.getElementById('playCard').style.display = remaining>0 ? 'block' : 'none';
  return remaining;
}
</script>
</body>
</html>
